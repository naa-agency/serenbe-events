
(function () {
  // Hide list while computing to avoid flicker
  $('[data-type="events-col"]').hide();

  // Selectors that might contain a visible time string
  const TIME_SELECTORS = [
    '[cms-item="start-time"]',
    '[cms-item="time"]',
    '[data-time="start"]',
    '[cms-item="hours"]',
    '[data-hours="start"]'
  ];

  // Elements that might carry a raw machine datetime or a date with time
  const DATE_SELECTORS = [
    '[cms-item="start-date"]',
    '[data-date="start"]',
    'time[cms-item="start-date"]',
    'time',
    'meta[itemprop="startDate"]'
  ];

  const RAW_DT_ATTRS = [
    'datetime', 'data-datetime', 'data-start', 'data-start-dt',
    'data-iso', 'data-wf-date', 'content', 'title', 'aria-label'
  ];

  // --- utils ----------------------------------------------------

  function txt($root, sel) {
    const el = $root.find(sel).first();
    return el.length ? String(el.text()).trim() : '';
  }

  function firstText($root, sels) {
    for (const s of sels) {
      const v = txt($root, s);
      if (v) return v;
    }
    return '';
  }

  function daysInMonth(y, m) {
    return new Date(y, m + 1, 0).getDate();
  }

  function toLocalIso(y, m, d, hh, mm) {
    const p = n => (n < 10 ? '0' + n : '' + n);
    return `${y}-${p(m + 1)}-${p(d)}T${p(hh)}:${p(mm)}`;
  }

  function keyToTs(key) {
    const m = String(key || '').match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})$/);
    if (!m) return NaN;
    return +new Date(
      parseInt(m[1], 10),
      parseInt(m[2], 10) - 1,
      parseInt(m[3], 10),
      parseInt(m[4], 10),
      parseInt(m[5], 10)
    );
  }

  // Parse "MM/DD/YYYY" or ISO "YYYY-MM-DD" with optional time, or natural strings like "December 7, 2024 1:30 PM"
  function parseDateFlexible(s) {
    if (!s) return new Date(NaN);
    s = String(s).trim();

    // MM/DD/YYYY [HH:MM] [AM|PM]
    const mdy = s.match(
      /^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:\s+(\d{1,2})(?::(\d{2}))?\s*(AM|PM)?)?$/i
    );
    if (mdy) {
      let [, mm, dd, yyyy, hh, min, ap] = mdy;
      mm = parseInt(mm, 10);
      dd = parseInt(dd, 10);
      yyyy = parseInt(yyyy, 10);
      hh = hh != null ? parseInt(hh, 10) : 0;
      min = min != null ? parseInt(min, 10) : 0;
      if (ap) {
        ap = ap.toUpperCase();
        if (ap === 'PM' && hh !== 12) hh += 12;
        if (ap === 'AM' && hh === 12) hh = 0;
      }
      return new Date(yyyy, mm - 1, dd, hh, min);
    }

    // ISO YYYY-MM-DD or YYYY-MM-DDTHH:MM
    const iso = s.match(/^(\d{4})-(\d{2})-(\d{2})(?:[T\s](\d{2})(?::(\d{2}))?)?$/);
    if (iso) {
      let [, yyyy, mm, dd, hh, min] = iso;
      return new Date(
        parseInt(yyyy, 10),
        parseInt(mm, 10) - 1,
        parseInt(dd, 10),
        hh != null ? parseInt(hh, 10) : 0,
        min != null ? parseInt(min, 10) : 0
      );
    }

    // Fallback - lets Date parse "December 7, 2024 1:30 PM" etc
    return new Date(s);
  }

  // Extract {h,m} from strings like "9:30 AM", "10am", "9a - 1p", "14:00"
  function parseTimeFromString(s) {
    if (!s) return null;
    s = String(s).toLowerCase();

    // Ranges - take the first time in the range
    const firstPart = s.split(/-|–|—/)[0];

    // 12h with minutes
    let m = firstPart.match(/(\d{1,2}):(\d{2})\s*(am|pm)/i);
    if (m) {
      let h = parseInt(m[1], 10);
      const min = parseInt(m[2], 10);
      const ap = m[3].toUpperCase();
      if (ap === 'PM' && h !== 12) h += 12;
      if (ap === 'AM' && h === 12) h = 0;
      return { h, m: min };
    }

    // 12h without minutes like "9am" or "9a"
    m = firstPart.match(/\b(\d{1,2})\s*(am|pm|a|p)\b/);
    if (m) {
      let h = parseInt(m[1], 10);
      const ap = m[2].toLowerCase();
      if ((ap === 'pm' || ap === 'p') && h !== 12) h += 12;
      if ((ap === 'am' || ap === 'a') && h === 12) h = 0;
      return { h, m: 0 };
    }

    // 24h like "14:30"
    m = firstPart.match(/\b(\d{1,2}):(\d{2})\b/);
    if (m) {
      return { h: parseInt(m[1], 10), m: parseInt(m[2], 10) };
    }

    return null;
  }

  // Try hard to get a Date with time from the DOM for one card
  function extractStartDateTime($el) {
    // 1) raw ISO from attributes if available
    for (const sel of DATE_SELECTORS) {
      const $nodes = $el.find(sel);
      if (!$nodes.length) continue;
      for (let i = 0; i < $nodes.length; i++) {
        const node = $nodes[i];
        for (const a of RAW_DT_ATTRS) {
          const v = node.getAttribute && node.getAttribute(a);
          if (v && /\d{4}-\d{2}-\d{2}/.test(v)) {
            const d = parseDateFlexible(v);
            if (!isNaN(d)) return d;
          }
        }
      }
    }

    // 2) combine visible date and visible time
    const dateText = (function () {
      for (const sel of DATE_SELECTORS) {
        const t = txt($el, sel);
        if (t) return t;
      }
      return '';
    })();

    const timeText = firstText($el, TIME_SELECTORS);

    if (dateText && timeText) {
      // If date is long form, just glue "date time" and let parser handle it
      const d = parseDateFlexible(`${dateText} ${timeText}`);
      if (!isNaN(d)) return d;
    }

    // 3) if dateText already includes time like "12/07/2024 1:30 PM"
    if (dateText) {
      const d2 = parseDateFlexible(dateText);
      if (!isNaN(d2)) return d2;
    }

    return new Date(NaN);
  }

  // Pull {h,m} with many fallbacks
  function getStartTimeHM($el) {
    // 1) try explicit time fields
    const t1 = parseTimeFromString(firstText($el, TIME_SELECTORS));
    if (t1) return t1;

    // 2) try attributes on the date node
    for (const sel of DATE_SELECTORS) {
      const $nodes = $el.find(sel);
      for (let i = 0; i < $nodes.length; i++) {
        const n = $nodes[i];
        for (const a of RAW_DT_ATTRS) {
          const v = n.getAttribute && n.getAttribute(a);
          if (v && /\d{2}:\d{2}/.test(v)) {
            const d = parseDateFlexible(v);
            if (!isNaN(d)) return { h: d.getHours(), m: d.getMinutes() };
          }
        }
        const text = $(n).text();
        const t = parseTimeFromString(text);
        if (t) return t;
      }
    }

    // 3) give up - midnight as last resort
    return { h: 0, m: 0 };
  }

  // Recurring parsing
  function parseRule(raw) {
    const s = String(raw || '')
      .toLowerCase()
      .replace(/[–—]/g, '-')  // normalize en/em dashes to hyphen
      .replace(/\s+/g, ' ')
      .trim();

    if (!s) return { type: null };

    if (s.includes('daily')) return { type: 'daily' };

    if (s.includes('weekly') || s.includes('every week') || s.startsWith('every ')) {
      const days = [];
      const short = ['sun','mon','tue','wed','thu','fri','sat'];
      const matches = s.match(/sun(day)?|mon(day)?|tue(sday)?|wed(nesday)?|thu(rsday)?|fri(day)?|sat(urday)?/g) || [];
      for (const d of matches) {
        const name = d.slice(0,3).toLowerCase();
        const idx = short.indexOf(name);
        if (idx >= 0) days.push(idx);
      }
      return { type: 'weekly', days: days.length ? Array.from(new Set(days)) : [0,1,2,3,4,5,6] };
    }

    if (s.includes('monthly')) {
      const nums = (s.match(/(\d{1,2})(?:st|nd|rd|th)?/g) || [])
        .map(n => parseInt(n, 10))
        .filter(n => !Number.isNaN(n) && n >= 1 && n <= 31);
      return { type: 'monthly', doms: nums.length ? Array.from(new Set(nums)).sort((a,b)=>a-b) : [1] };
    }

    return { type: null };
  }

  function nextOccurrence(rule, minDate, startDateLimit) {
    const base = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
    const limit = startDateLimit && !isNaN(startDateLimit)
      ? new Date(startDateLimit.getFullYear(), startDateLimit.getMonth(), startDateLimit.getDate())
      : null;

    const notBefore = limit && limit > base ? limit : base;

    if (rule.type === 'daily') return notBefore;

    if (rule.type === 'weekly') {
      for (let i = 0; i < 14; i++) {
        const c = new Date(notBefore);
        c.setDate(notBefore.getDate() + i);
        if (rule.days.includes(c.getDay())) return c;
      }
      return notBefore;
    }

    if (rule.type === 'monthly') {
      const y = notBefore.getFullYear();
      const m = notBefore.getMonth();
      for (const dom of rule.doms) {
        const d = Math.min(dom, daysInMonth(y, m));
        const cand = new Date(y, m, d);
        if (cand >= notBefore) return cand;
      }
      const nm = m + 1;
      const ny = m === 11 ? y + 1 : y;
      const mm = nm % 12;
      const d = Math.min(rule.doms[0], daysInMonth(ny, mm));
      return new Date(ny, mm, d);
    }

    return notBefore;
  }

  function sortItemsByKey(wrapperSel, attrName) {
    const $wrapper = $(wrapperSel);
    $wrapper
      .find('.w-dyn-item')
      .sort(function (a, b) {
        const ta = keyToTs($(a).attr(attrName));
        const tb = keyToTs($(b).attr(attrName));
        if (isNaN(ta) && isNaN(tb)) return 0;
        if (isNaN(ta)) return 1;
        if (isNaN(tb)) return -1;
        if (ta === tb) {
          const at = $(a).find('[cms-item="title"]').text().trim();
          const bt = $(b).find('[cms-item="title"]').text().trim();
          return at.localeCompare(bt);
        }
        return ta - tb;
      })
      .appendTo($wrapper);
  }

  function generateMonthList(endDate) {
    const today = new Date();
    const startMonth = today.getMonth();
    const startYear = today.getFullYear();
    const months = [
      'January','February','March','April','May','June',
      'July','August','September','October','November','December'
    ];
    const out = [];
    let m = startMonth, y = startYear;

    while (true) {
      out.push(`${months[m]} ${y}`);
      if (endDate) {
        const e = parseDateFlexible(endDate);
        if (!isNaN(e) && (y > e.getFullYear() || (y === e.getFullYear() && m >= e.getMonth()))) break;
      }
      if (!endDate && out.length === 12) break;
      m++;
      if (m === 12) { m = 0; y++; }
    }
    return out;
  }

  function loadFilterDropdown() {
    const months = generateMonthList();
    $('[data-role="fil-toggle"]').on('click', function () {
      $('[data-role="fil-list"]').toggleClass('hidden');
    });
    $(document).on('click', function (e) {
      if (!$(e.target).closest('.dropdown--filter').length) {
        $('[data-role="fil-list"]').addClass('hidden');
      }
    });
    $('[data-role="fil-list"] .w-form-label"]').each(function (i) { $(this).text(months[i]); });
    $('[data-role="fil-list"] input[type="radio"]').each(function (i) { $(this).val(months[i]); });
  }

  function bindMonthFilter() {
    $('[data-role="fil-list"] input[type="radio"]').on('change', function () {
      $('[data-role="no-result"]').addClass('hidden');

      const monthValue = $(this).val();
      let count = 0;

      $('#sliderParentEvents .w-dyn-item').each(function () {
        const itemMonths = [];
        $(this).find('[filter="date"]').each(function () { itemMonths.push($(this).text()); });
        if (itemMonths.includes(monthValue)) {
          $(this).removeClass('hidden'); count++;
        } else {
          $(this).addClass('hidden');
        }
      });

      $('[data-role="filter-head"]').addClass('hidden');
      $('[data-role="tag"]').removeClass('hidden');
      $('[data-role="tag-text"]').text(monthValue);

      if (count === 0) $('[data-role="no-result"]').removeClass('hidden');
    });

    $('[data-role="tag"]').on('click', function () {
      $('#sliderParentEvents .w-dyn-item').removeClass('hidden');
      $('[data-role="filter-head"]').removeClass('hidden');
      $('[data-role="tag"]').addClass('hidden');
      $('[data-role="no-result"]').addClass('hidden');
    });
  }

  function fillMonthTagsOnItem($el, endDateText) {
    const months = generateMonthList(endDateText);
    const $blk = $el.find('[filter="date-block"]');
    const $tag = $el.find('[filter="date"]');
    months.forEach(m => {
      const $new = $tag.clone();
      $new.text(m).appendTo($blk);
    });
    $tag.remove();
  }

  // --- main -----------------------------------------------------

  window.fsAttributes = window.fsAttributes || [];
  window.fsAttributes.push([
    'cmsload',
    listInstances => {
      const [list] = listInstances;
      loadFilterDropdown();

      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

      list.items.forEach(item => {
        const $el = $(item.element);

        const ruleRaw = txt($el, '[date-recurring="formula"]').replace(/\s+/g, ' ');
        const rule = parseRule(ruleRaw);

        const startDateDom = extractStartDateTime($el);  // Date with time if possible
        const startHM = !isNaN(startDateDom) ? { h: startDateDom.getHours(), m: startDateDom.getMinutes() }
                                             : getStartTimeHM($el);

        const endDateText = txt($el, '[data-recurring="end-date"]') || txt($el, '[cms-item="end-date"]');

        // Base date for next occurrence
        const base = !isNaN(startDateDom)
          ? new Date(Math.max(today.getTime(), +new Date(startDateDom.getFullYear(), startDateDom.getMonth(), startDateDom.getDate())))
          : today;

        // Date-only next occurrence
        let occDate = base;
        if (rule.type) {
          occDate = nextOccurrence(rule, base, !isNaN(startDateDom) ? startDateDom : null);
        } else if (!isNaN(startDateDom)) {
          occDate = new Date(startDateDom.getFullYear(), startDateDom.getMonth(), startDateDom.getDate());
        }

        // Final sortable key with a guaranteed time component
        const sortKey = toLocalIso(occDate.getFullYear(), occDate.getMonth(), occDate.getDate(), startHM.h, startHM.m);
        $el.attr('data-sort-dt', sortKey);

        // Remove expired by end-date if present
        if (endDateText) {
          const end = parseDateFlexible(endDateText);
          if (!isNaN(end)) {
            const eod = new Date(end.getFullYear(), end.getMonth(), end.getDate(), 23, 59, 59);
            if (now > eod) {
              $el.remove();
              return;
            }
          }
        }

        // Month tags for filter UI
        fillMonthTagsOnItem($el, endDateText);
      });

      // Reveal + sort
      $('[data-type="events-col"]').show();
      $('[data-role="loading"]').hide();
      sortItemsByKey('#sliderParentEvents', 'data-sort-dt');

      // Filter binds
      bindMonthFilter();

      // Optional debug - visit the page with ?debug=1 to show computed keys
      if (/\bdebug=1\b/.test(location.search)) {
        $('#sliderParentEvents .w-dyn-item').each(function(){
          const k = $(this).attr('data-sort-dt');
          const pill = $('<div/>').css({
            position:'absolute', top:6, left:6, background:'#0008', color:'#fff',
            padding:'4px 6px', borderRadius:'4px', font:'12px/1.2 system-ui', zIndex:5
          }).text(k || 'no-key');
          $(this).css('position','relative').append(pill);
        });
        console.table($('#sliderParentEvents .w-dyn-item').map(function(){
          return {
            title: $(this).find('[cms-item="title"]').text().trim(),
            key: $(this).attr('data-sort-dt') || ''
          };
        }).get());
      }
    }
  ]);
})();
